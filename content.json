{"pages":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/friends/index.html"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/about/index.html"}],"posts":[{"title":"YUYV转YUV420P","text":"之前接触到一个YUYV的摄像头,需要将采集到的YUYV数据转换为YUV420P数据.在经历了一些弯路的同时,发现了网上流传的一些资料有误,遂写此博文. 基础 YUYV格式介绍 YUY420P格式介绍 转换 基础# YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V”表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。 对于每一个Y或U或V分量,其长度都是1个字节.YUV420P和YUYV本质上的区别就是采样方式的不同. 由于作者水平限制,文中可能出现一些纰漏,欢迎指正… YUYV格式介绍#yuyv的存储结构如下表,如果是uyvy的话,就是顺序改变一下. Y0 U0 Y1 V0 Y2 U2 Y3 V2 Y4 U4 Y5 V4 Y6 U6 Y7 V6 Y8 U8 Y9 V8 Y10 U10 Y11 V10 Y12 U12 Y13 V12 Y14 U14 Y15 V14 看起来这个结构很奇怪,对吧? 而且UV分量还没有奇数的份.我的理解是YUYV对应着的是两个像素,其中第一个像素由Y0,U0,V0组成,第二个像素由Y1组成,那么在一张图片上,YUYV就是下表的样子. Y0,U0,V0 Y1,U0,V0 Y2,V2,U2 Y3,V2,U2 Y4,U4,V4 Y5,U4,V4 Y6,U6,V6 Y7,U6,V6 Y8,U8,V8 Y9,U8,V8 Y10,U10,V10 Y11,U10,V10 Y12,U12,V12 Y13,U12,V12 Y14,U14,V14 Y15,U14,V14 这样一来,UV分量看起来就舒服多了,和Y分量完美对应起来.这就是第一个表中没有奇数UV分量的原因. YUV420P和YUYV本质上的区别就是采样方式的不同. YUYV使用了隔列采样.从中可以看到, 4个字节,一组YUYV代表了两个像素,因此如果使用YUYV存储,那么文件的大小size = width height 2容易看出,上面两个表描述了一个4*4像素大小的图片.其大小为32字节. YUY420P格式介绍#同样,首先来看一张4*4像素大小的yuv420p存储结构,如下表. Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15 ——- ——- ——- ——- U0 U2 U8 U10 ——- ——- ——- ——- V0 V2 V8 V10 为了方便理解,没有按顺序排列UV分量,怎么好理解怎么来,这些数字都不重要!首先YUV420P将YUV三个分量分别打包,Y存放在一起,U放在一起,V放在一起.你可能会觉得UV分量少了,但是UV分量就是这么多,并没有少.我们来看在图片中的YUV420P: Y0,U0,V0 Y1,U0,V0 Y2,V2,U2 Y3,V2,U2 Y4,U0,V0 Y5,U0,V0 Y6,V2,U2 Y7,V2,U2 Y8,U8,V8 Y9,U8,V8 Y10,U10,V10 Y11,U10,V10 Y12,U8,V8 Y13,U8,V8 Y14,U10,V10 Y15,U10,V10 YUV420P和YUYV本质上的区别就是采样方式的不同. YUV420使用了隔行隔列采样.可以理解成YUV420,在YUV422的基础上抛弃了偶数行的UV分量,(或者抛弃奇数行,或者U分量抛弃奇数行,V分量抛弃偶数行…)也就是说,四个相邻的像素共用一个UV分量,U0和V0提供给了Y0,Y1,Y4,Y5四个像素.那么采用了YUV420的44像素图片,Y分量大小是width height;U分量大小是width height / 4;V分量大小是width height / 4;整个图片大小就是:size = width height 3 / 2. 转换#对比yuyv和yuv420p的存储方式 yuyv Y0 U0 Y1 V0 Y2 U2 Y3 V2 Y4 U4 Y5 V4 Y6 U6 Y7 V6 Y8 U8 Y9 V8 Y10 U10 Y11 V10 Y12 U12 Y13 V12 Y14 U14 Y15 V14 yuv420p Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15 ——- ——- ——- ——- U0 U2 U8 U10 ——- ——- ——- ——- V0 V2 V8 V10 那么就是读入yuyv后,把它按照yuv420的结构重新排列一下,抛弃偶数行的UV分量就可以了.分析完YUYV和YUV420P后,我写了一段yuyv转yuv420的程序,首先请分配好out的空间:size = width height 3 / 2. 1234567891011121314151617181920212223242526void yuyv_to_yuv420P(uint8_t *in, uint8_t*out, int width, int height) { uint8_t *y, *u, *v; int i, j, offset = 0, yoffset = 0; y = out; //yuv420的y放在前面 u = out + (width * height); //yuv420的u放在y后 v = out + (width * height * 5 / 4); //yuv420的v放在u后 //总共size = width * height * 3 / 2 for(j = 0; j &lt; height; j++) { yoffset = 2 * width * j; for(i = 0; i &lt; width * 2; i = i + 4) { offset = yoffset + i; *(y ++) = *(in + offset); *(y ++) = *(in + offset + 2); if(j % 2 == 1) //抛弃奇数行的UV分量 { *(u ++) = *(in + offset + 1); *(v ++) = *(in + offset + 3); } } } } —|— 程序非常正常,完美运行! __","link":"/2018/03/07/YUYV(YUV422)%20to%20YUV420P/"},{"title":"在ZorinOS中优雅地使用rosdep","text":"虽说ZorinOS和Elementary OS一样都是基于Ubuntu，但在ZorinOS中使用rosdep会提示Unsupport OS，而后者却不会，虽然我们可以在rosdep后加上参数–os=ubuntu:bionic（对应ubuntu18）临时解决，但总感觉不够优雅。 以下为笔者版本 ros:melodiczorinos:15（对应ubuntu18） 以下来一个一劳永逸的方法（前提是ros不更新，不然就再改一次）/usr/lib/python2.7/dist-packages/rosdep2/platform/debian.py 首先修改这个文件，找到这一句 1from rospkg.os_detect import OS_DEBIAN, OS_LINARO, OS_UBUNTU, OS_ELEMENTARY OS_MX, OsDetect, read_os_release 改成（也就是加上OS_ZORIN）1from rospkg.os_detect import OS_DEBIAN, OS_LINARO, OS_UBUNTU, OS_ELEMENTARY, OS_ZORIN, OS_MX, OsDetect, read_os_release 然后在函数def register_platforms(context):里面加上register_zorin(context) 另外加上一个函数12345678def register_zorin(context): # ZorinOS is an alias for Ubuntu. If ZorinOS is detected and it's # not set as an override force ubuntu. (os_name, os_version) = context.get_os_name_and_version() if os_name == OS_ZORIN and not context.os_override: print('rosdep detected OS: [%s] aliasing it to: [%s]' % (OS_ZORIN , OS_UBUNTU), file=sys.stderr) context.set_os_override(OS_UBUNTU, context.os_detect.get_codename()) 保存该文件，接下来是/usr/lib/python2.7/dist-packages/rospkg/os_detect.py 在720行左右加上OS_ZORIN = 'zorin' 在752行左右加上OsDetect.register_default(OS_ZORIN, LsbDetect(&quot;zorin&quot;))保存完成！ 接下来再试试rosdep，已经可以完美使用了。","link":"/2020/02/25/%E5%9C%A8ZorinOS%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8rosdep/"},{"title":"视觉SLAM-双目点云","text":"详见正文 题目 解决 结果 题目# 双目生成点云这道题，很多人，包括我做的时候深度都有问题。如下图。这是别人博客上的一张结果，我做的时候也是这样，仔细观察可以发现，在这里深度图的宽是原图的一半，深度图读了两次，图中间可以看到一个电线杆的形状，右边又可以看到一个电线杆。但是原深度图的长宽是没有问题的。 解决#这涉及到png的交错存储问题，可以理解成隔行扫描，故问题就很明显了。解决方法有很多种： 转换png格式，改为无交错 修改程序，如下（有其他改法）123456789101112131415161718192021222324252627282930313233int main(int argc, char **argv) { // 内参 double fx = 718.856, fy = 718.856, cx = 607.1928, cy = 185.2157; // 间距 double b = 0.573; // 读取图像 cv::Mat left = cv::imread(left_file, 0); cv::Mat right = cv::imread(right_file, 0); cv::Mat disparity = cv::imread(disparity_file,0); // disparty 为CV_8U,单位为像素 // 生成点云 vector&lt;Vector4d, Eigen::aligned_allocator&lt;Vector4d&gt;&gt; pointcloud; // TODO 根据双目模型计算点云 // 如果你的机器慢，请把后面的v++和u++改成v+=2, u+=2 for (int v = 0; v &lt; left.rows; v++){ for (int u = 0; u &lt; left.cols; u++) { Vector4d point( 0, 0, 0, left.at&lt;uchar&gt;(v, u) / 255.0); // 前三维为xyz,第四维为颜色 // start your code here (~6 lines) // 根据双目模型计算 point 的位置 unsigned short d = disparity.at&lt;unsigned short&gt;(v, u/2); point[2] = 200 * log(65536.0 / double(d) + 1); point[0] = (u - cx) * point[2] / fx; point[1] = (v - cy) * point[2] / fy; pointcloud.push_back(point); // end your code here } } // 画出点云 showPointCloud(pointcloud); return 0;} 结果#","link":"/2019/09/07/%E8%A7%86%E8%A7%89SLAM-%E6%B7%B1%E8%93%9D%E5%AD%A6%E9%99%A2-%E7%AC%AC%E4%BA%94%E8%AE%B2-%E5%8F%8C%E7%9B%AE%E7%94%9F%E6%88%90%E7%82%B9%E4%BA%91/"}],"tags":[{"name":"SLAM","slug":"SLAM","link":"/tags/SLAM/"},{"name":"YUV","slug":"YUV","link":"/tags/YUV/"},{"name":"ros Linux ZorinOS","slug":"ros-Linux-ZorinOS","link":"/tags/ros-Linux-ZorinOS/"}],"categories":[{"name":"SLAM","slug":"SLAM","link":"/categories/SLAM/"},{"name":"计算机视觉","slug":"计算机视觉","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"}]}