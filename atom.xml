<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yida</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.mchook.cn/"/>
  <updated>2020-04-23T04:22:24.872Z</updated>
  <id>http://blog.mchook.cn/</id>
  
  <author>
    <name>Yida</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>视觉SLAM-深蓝学院-第五讲-双目生成点云</title>
    <link href="http://blog.mchook.cn/2020/04/23/%E8%A7%86%E8%A7%89SLAM-%E6%B7%B1%E8%93%9D%E5%AD%A6%E9%99%A2-%E7%AC%AC%E4%BA%94%E8%AE%B2-%E5%8F%8C%E7%9B%AE%E7%94%9F%E6%88%90%E7%82%B9%E4%BA%91/"/>
    <id>http://blog.mchook.cn/2020/04/23/%E8%A7%86%E8%A7%89SLAM-%E6%B7%B1%E8%93%9D%E5%AD%A6%E9%99%A2-%E7%AC%AC%E4%BA%94%E8%AE%B2-%E5%8F%8C%E7%9B%AE%E7%94%9F%E6%88%90%E7%82%B9%E4%BA%91/</id>
    <published>2020-04-23T03:38:08.497Z</published>
    <updated>2020-04-23T04:22:24.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a><p><img src="https://raw.githubusercontent.com/kuzen/typora-image/master/img/20200423120001.png" alt=""></p><p>双目生成点云这道题，很多人，包括我做的时候深度都有问题。如下图。这是别人博客上的一张结果，我做的时候也是这样，仔细观察可以发现，在这里深度图的宽是原图的一半，深度图读了两次，图中间可以看到一个电线杆的形状，右边又可以看到一个电线杆。但是原深度图的长宽是没有问题的。</p><p><img src="https://raw.githubusercontent.com/kuzen/typora-image/master/img/%E8%A7%86%E8%A7%89SLAM-%E5%8F%8C%E7%9B%AE%E7%82%B9%E4%BA%91-2.png" alt=""></p><p>这涉及到png的交错存储问题，可以理解成隔行扫描，故问题就很明显了。解决方法有很多种：</p><ol><li>转换png格式，改为无交错</li><li>修改程序，如下（有其他改法）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内参</span></span><br><span class="line">    <span class="keyword">double</span> fx = <span class="number">718.856</span>, fy = <span class="number">718.856</span>, cx = <span class="number">607.1928</span>, cy = <span class="number">185.2157</span>;</span><br><span class="line">    <span class="comment">// 间距</span></span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">0.573</span>;</span><br><span class="line">    <span class="comment">// 读取图像</span></span><br><span class="line">    cv::Mat left = cv::imread(left_file, <span class="number">0</span>);</span><br><span class="line">    cv::Mat right = cv::imread(right_file, <span class="number">0</span>);</span><br><span class="line">    cv::Mat disparity =</span><br><span class="line">        cv::imread(disparity_file,<span class="number">0</span>);  <span class="comment">// disparty 为CV_8U,单位为像素</span></span><br><span class="line">    <span class="comment">// 生成点云</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Vector4d, Eigen::aligned_allocator&lt;Vector4d&gt;&gt; pointcloud;</span><br><span class="line">    <span class="comment">// TODO 根据双目模型计算点云</span></span><br><span class="line">    <span class="comment">// 如果你的机器慢，请把后面的v++和u++改成v+=2, u+=2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; left.rows; v++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; left.cols; u++) &#123;</span><br><span class="line">            <span class="function">Vector4d <span class="title">point</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                left.at&lt;uchar&gt;(v, u) / <span class="number">255.0</span>)</span></span>;  <span class="comment">// 前三维为xyz,第四维为颜色</span></span><br><span class="line">            <span class="comment">// start your code here (~6 lines)</span></span><br><span class="line">            <span class="comment">// 根据双目模型计算 point 的位置</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> d = disparity.at&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(v, u/<span class="number">2</span>);</span><br><span class="line">            point[<span class="number">2</span>] = <span class="number">200</span> * <span class="built_in">log</span>(<span class="number">65536.0</span> / <span class="keyword">double</span>(d) + <span class="number">1</span>);</span><br><span class="line">            point[<span class="number">0</span>] = (u - cx) * point[<span class="number">2</span>] / fx;</span><br><span class="line">            point[<span class="number">1</span>] = (v - cy) * point[<span class="number">2</span>] / fy;</span><br><span class="line">            pointcloud.push_back(point);</span><br><span class="line">            <span class="comment">// end your code here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画出点云</span></span><br><span class="line">    showPointCloud(pointcloud);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://raw.githubusercontent.com/kuzen/typora-image/master/img/%E8%A7%86%E8%A7%89SLAM-%E5%8F%8C%E7%9B%AE%E7%82%B9%E4%BA%91-%E6%95%88%E6%9E%9C.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>在ZorinOS中优雅地使用rosdep</title>
    <link href="http://blog.mchook.cn/2020/04/23/%E5%9C%A8ZorinOS%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8rosdep/"/>
    <id>http://blog.mchook.cn/2020/04/23/%E5%9C%A8ZorinOS%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8rosdep/</id>
    <published>2020-04-23T03:36:10.877Z</published>
    <updated>2020-04-23T04:20:11.655Z</updated>
    
    <content type="html"><![CDATA[<p>虽说ZorinOS和Elementary OS一样都是基于Ubuntu，但在ZorinOS中使用rosdep会提示Unsupport OS，而后者却不会，虽然我们可以在rosdep后加上参数–os=ubuntu:bionic（对应ubuntu18）临时解决，但总感觉不够优雅。</p><a id="more"></a><p>以下为笔者版本 </p><blockquote><p>ros:melodic<br>zorinos:15（对应ubuntu18）</p></blockquote><p>以下来一个一劳永逸的方法（前提是ros不更新，不然就再改一次）<br><code>/usr/lib/python2.7/dist-packages/rosdep2/platform/debian.py</code></p><ol><li>首先修改这个文件，找到这一句</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rospkg.os_detect <span class="keyword">import</span> OS_DEBIAN, OS_LINARO, OS_UBUNTU, OS_ELEMENTARY OS_MX, OsDetect, read_os_release</span><br></pre></td></tr></table></figure><p>改成（也就是加上<code>OS_ZORIN</code>）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rospkg.os_detect <span class="keyword">import</span> OS_DEBIAN, OS_LINARO, OS_UBUNTU, OS_ELEMENTARY, OS_ZORIN, OS_MX, OsDetect, read_os_release</span><br></pre></td></tr></table></figure></p><ol start="2"><li>然后在函数<code>def register_platforms(context):</code>里面加上<code>register_zorin(context)</code></li></ol><ol start="3"><li>另外加上一个函数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_zorin</span><span class="params">(context)</span>:</span></span><br><span class="line">    <span class="comment"># ZorinOS is an alias for Ubuntu. If ZorinOS is detected and it's</span></span><br><span class="line">    <span class="comment"># not set as an override force ubuntu.</span></span><br><span class="line">    (os_name, os_version) = context.get_os_name_and_version()</span><br><span class="line">    <span class="keyword">if</span> os_name == OS_ZORIN <span class="keyword">and</span> <span class="keyword">not</span> context.os_override:</span><br><span class="line">        print(<span class="string">'rosdep detected OS: [%s] aliasing it to: [%s]'</span> %</span><br><span class="line">              (OS_ZORIN , OS_UBUNTU), file=sys.stderr)</span><br><span class="line">        context.set_os_override(OS_UBUNTU, context.os_detect.get_codename())</span><br></pre></td></tr></table></figure></li></ol><p>保存该文件，接下来是<br><code>/usr/lib/python2.7/dist-packages/rospkg/os_detect.py</code></p><ol start="4"><li>在720行左右加上<code>OS_ZORIN = &#39;zorin&#39;</code></li><li>在752行左右加上<code>OsDetect.register_default(OS_ZORIN, LsbDetect(&quot;zorin&quot;))</code><br>保存完成！</li></ol><p>接下来再试试rosdep，已经可以完美使用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽说ZorinOS和Elementary OS一样都是基于Ubuntu，但在ZorinOS中使用rosdep会提示Unsupport OS，而后者却不会，虽然我们可以在rosdep后加上参数–os=ubuntu:bionic（对应ubuntu18）临时解决，但总感觉不够优雅。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>YUYV(YUV422) to YUV420P</title>
    <link href="http://blog.mchook.cn/2020/04/23/YUYV(YUV422)%20to%20YUV420P/"/>
    <id>http://blog.mchook.cn/2020/04/23/YUYV(YUV422)%20to%20YUV420P/</id>
    <published>2020-04-23T03:34:23.565Z</published>
    <updated>2020-04-23T04:19:39.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前接触到一个YUYV的摄像头,需要将采集到的YUYV数据转换为YUV420P数据.在经历了一些弯路的同时,发现了网上流传的一些资料有误,遂写此博文.</p><hr><a id="more"></a><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><blockquote><p>YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V”<br>表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</p></blockquote><p>对于每一个Y或U或V分量,其长度都是1个字节.YUV420P和YUYV本质上的区别就是采样方式的不同.</p><p><strong>由于作者水平限制,文中可能出现一些纰漏,欢迎指正…</strong></p><h1 id="YUYV格式介绍"><a href="#YUYV格式介绍" class="headerlink" title="YUYV格式介绍"></a>YUYV格式介绍</h1><p>yuyv的存储结构如下表,如果是uyvy的话,就是顺序改变一下.</p><table><thead><tr><th>Y0</th><th>U0</th><th>Y1</th><th>V0</th><th>Y2</th><th>U2</th><th>Y3</th><th>V2</th></tr></thead><tbody><tr><td>Y4</td><td>U4</td><td>Y5</td><td>V4</td><td>Y6</td><td>U6</td><td>Y7</td><td>V6</td></tr><tr><td>Y8</td><td>U8</td><td>Y9</td><td>V8</td><td>Y10</td><td>U10</td><td>Y11</td><td>V10</td></tr><tr><td>Y12</td><td>U12</td><td>Y13</td><td>V12</td><td>Y14</td><td>U14</td><td>Y15</td><td>V14</td></tr></tbody></table><p>看起来这个结构很奇怪,对吧? 而且UV分量还没有奇数的份.<br>我的理解是YUYV对应着的是两个像素,其中第一个像素由Y0,U0,V0组成,第二个像素由Y1组成,那么在一张图片上,YUYV就是下表的样子.</p><table><thead><tr><th>Y0,U0,V0</th><th>Y1,U0,V0</th><th>Y2,V2,U2</th><th>Y3,V2,U2</th></tr></thead><tbody><tr><td>Y4,U4,V4</td><td>Y5,U4,V4</td><td>Y6,U6,V6</td><td>Y7,U6,V6</td></tr><tr><td>Y8,U8,V8</td><td>Y9,U8,V8</td><td>Y10,U10,V10</td><td>Y11,U10,V10</td></tr><tr><td>Y12,U12,V12</td><td>Y13,U12,V12</td><td>Y14,U14,V14</td><td>Y15,U14,V14</td></tr></tbody></table><p>这样一来,UV分量看起来就舒服多了,和Y分量完美对应起来.这就是第一个表中没有奇数UV分量的原因.<br> <strong>YUV420P和YUYV本质上的区别就是采样方式的不同. YUYV使用了隔列采样.</strong><br>从中可以看到, 4个字节,一组YUYV代表了两个像素,因此如果使用YUYV存储,那么文件的大小size = width <em> height </em> 2<br>容易看出,上面两个表描述了一个4*4像素大小的图片.其大小为32字节.</p><hr><h1 id="YUY420P格式介绍"><a href="#YUY420P格式介绍" class="headerlink" title="YUY420P格式介绍"></a>YUY420P格式介绍</h1><p>同样,首先来看一张4*4像素大小的yuv420p存储结构,如下表.</p><table><thead><tr><th>Y0</th><th>Y1</th><th>Y2</th><th>Y3</th></tr></thead><tbody><tr><td>Y4</td><td>Y5</td><td>Y6</td><td>Y7</td></tr><tr><td>Y8</td><td>Y9</td><td>Y10</td><td>Y11</td></tr><tr><td>Y12</td><td>Y13</td><td>Y14</td><td>Y15</td></tr><tr><td>——-</td><td>——-</td><td>——-</td><td>——-</td></tr><tr><td>U0</td><td>U2</td><td>U8</td><td>U10</td></tr><tr><td>——-</td><td>——-</td><td>——-</td><td>——-</td></tr><tr><td>V0</td><td>V2</td><td>V8</td><td>V10</td></tr></tbody></table><p><strong>为了方便理解,没有按顺序排列UV分量,怎么好理解怎么来,这些数字都不重要!</strong><br>首先YUV420P将YUV三个分量分别打包,Y存放在一起,U放在一起,V放在一起.你可能会觉得UV分量少了,但是UV分量就是这么多,并没有少.我们来看在图片中的YUV420P:</p><table><thead><tr><th>Y0,U0,V0</th><th>Y1,U0,V0</th><th>Y2,V2,U2</th><th>Y3,V2,U2</th></tr></thead><tbody><tr><td>Y4,U0,V0</td><td>Y5,U0,V0</td><td>Y6,V2,U2</td><td>Y7,V2,U2</td></tr><tr><td>Y8,U8,V8</td><td>Y9,U8,V8</td><td>Y10,U10,V10</td><td>Y11,U10,V10</td></tr><tr><td>Y12,U8,V8</td><td>Y13,U8,V8</td><td>Y14,U10,V10</td><td>Y15,U10,V10</td></tr></tbody></table><p><strong>YUV420P和YUYV本质上的区别就是采样方式的不同. YUV420使用了隔行隔列采样.</strong><br>可以理解成YUV420,在YUV422的基础上抛弃了偶数行的UV分量,(或者抛弃奇数行,或者U分量抛弃奇数行,V分量抛弃偶数行…)<br>也就是说,四个相邻的像素共用一个UV分量,U0和V0提供给了Y0,Y1,Y4,Y5四个像素.<br>那么采用了YUV420的4<em>4像素图片,Y分量大小是width </em> height;<br>U分量大小是width <em> height / 4;<br>V分量大小是width </em> height / 4;<br>整个图片大小就是:<br>size = width <em> height </em> 3 / 2.</p><hr><h1 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h1><p>对比yuyv和yuv420p的存储方式</p><ul><li>yuyv </li></ul><table><thead><tr><th>Y0</th><th>U0</th><th>Y1</th><th>V0</th><th>Y2</th><th>U2</th><th>Y3</th><th>V2</th></tr></thead><tbody><tr><td>Y4</td><td>U4</td><td>Y5</td><td>V4</td><td>Y6</td><td>U6</td><td>Y7</td><td>V6</td></tr><tr><td>Y8</td><td>U8</td><td>Y9</td><td>V8</td><td>Y10</td><td>U10</td><td>Y11</td><td>V10</td></tr><tr><td>Y12</td><td>U12</td><td>Y13</td><td>V12</td><td>Y14</td><td>U14</td><td>Y15</td><td>V14</td></tr></tbody></table><ul><li>yuv420p </li></ul><table><thead><tr><th>Y0</th><th>Y1</th><th>Y2</th><th>Y3</th></tr></thead><tbody><tr><td>Y4</td><td>Y5</td><td>Y6</td><td>Y7</td></tr><tr><td>Y8</td><td>Y9</td><td>Y10</td><td>Y11</td></tr><tr><td>Y12</td><td>Y13</td><td>Y14</td><td>Y15</td></tr><tr><td>——-</td><td>——-</td><td>——-</td><td>——-</td></tr><tr><td>U0</td><td>U2</td><td>U8</td><td>U10</td></tr><tr><td>——-</td><td>——-</td><td>——-</td><td>——-</td></tr><tr><td>V0</td><td>V2</td><td>V8</td><td>V10</td></tr></tbody></table><p>那么就是读入yuyv后,把它按照yuv420的结构重新排列一下,抛弃偶数行的UV分量就可以了.<br>分析完YUYV和YUV420P后,我写了一段yuyv转yuv420的程序,首先请分配好out的空间:size = width <em> height </em> 3 / 2.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yuyv_to_yuv420P</span><span class="params">(<span class="keyword">uint8_t</span> *in, <span class="keyword">uint8_t</span>*out, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"> <span class="keyword">uint8_t</span> *y, *u, *v;  </span><br><span class="line"> <span class="keyword">int</span> i, j, offset = <span class="number">0</span>, yoffset = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line"> y = out;                                    <span class="comment">//yuv420的y放在前面  </span></span><br><span class="line"> u = out + (width * height);                 <span class="comment">//yuv420的u放在y后  </span></span><br><span class="line"> v = out + (width * height * <span class="number">5</span> / <span class="number">4</span>);         <span class="comment">//yuv420的v放在u后  </span></span><br><span class="line">    <span class="comment">//总共size = width * height * 3 / 2  </span></span><br><span class="line">  </span><br><span class="line"> <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; height; j++)  </span><br><span class="line"> &#123;  </span><br><span class="line">  yoffset = <span class="number">2</span> * width * j;  </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; width * <span class="number">2</span>; i = i + <span class="number">4</span>)  </span><br><span class="line">  &#123;  </span><br><span class="line">   offset = yoffset + i;  </span><br><span class="line">   *(y ++) = *(in + offset);  </span><br><span class="line">   *(y ++) = *(in + offset + <span class="number">2</span>);  </span><br><span class="line">   <span class="keyword">if</span>(j % <span class="number">2</span> == <span class="number">1</span>)                      <span class="comment">//抛弃奇数行的UV分量  </span></span><br><span class="line">   &#123;  </span><br><span class="line">    *(u ++) = *(in + offset + <span class="number">1</span>);  </span><br><span class="line">    *(v ++) = *(in + offset + <span class="number">3</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—|—  </p><p>程序非常正常,完美运行!</p><p>__</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前接触到一个YUYV的摄像头,需要将采集到的YUYV数据转换为YUV420P数据.在经历了一些弯路的同时,发现了网上流传的一些资料有误,遂写此博文.&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
